# module to build benchmarks
# should create folder structure
import os
import shutil
import requests
import yaml
from datasets import load_dataset
# from pathlib import Path # ???


about_template = """# {bench_name}

{text}

Generated by BenchTools
"""

class Bench():
    '''
        Benchmark with multiple tasks


    Attributes
    ----------
    bench_name : str
        Name of the benchmark.
    bench_path: str
        Path to where the benchmark folder and all its content reside
    task_folder:
        Path to tasks folder insise benchmark folder
    log folder:
        Path to logs folder inside benchmark folder
    tasks: tuple<str,str>
        A tas
    is_built: bool

    Methods
    -------
    build()
        Build the benchmark directory.
    add_task()
        Add new tasks to the benchmark
    run()
        Run one task or all tasks of the benchmark.
    '''
    def __init__(self, name, path = '.',concept = None):
        '''
        Initialize the benchmark object with the name and path to the benchmark folder.

        Parameters:
        -----------
        name: str
            name of the benchmark will be used for folder
        path: str or buffer
            path where the benchmark will be stored 
        
        '''
        # load tasks from file structre and instantiate task objects for each, store those in a list.
        #    loading will 
        self.display_name = name.strip()
        self.bench_concept  = concept if concept else f'a benchmark about {name.strip()}'
        self.bench_name = name.strip().replace(" ", "_").lower()
        self.base_path = path
        self.bench_path = os.path.join(path, self.bench_name)
        self.tasks_folder = os.path.join(self.bench_path, 'tasks')
        self.tasks = []
        self.written = os.path.exists(self.bench_path)

    @classmethod
    def load(bench_path):
        '''
        Load a benchmark from a given path. The path should point to the benchmark folder.

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder. The folder should contain the about.md file, tasks folder and logs folder.

        Returns:
        --------
        Bench
            An instance of the Bench class with the loaded benchmark.
        '''
        if not os.path.exists(bench_path):
            raise ValueError("The passed path doesn't exist.")
        
        
    

    def initialize_dir(self, about_body=None, no_git=False):
        '''
        write out the benchmark folder 
        
        Parameters:
        -----------
        about_text: str
            description of the benchmark to be included in the about.md file
        no_git: bool
            whether to initialize a git repository in the benchmark folder
        new_tasks: list of tuples (task_name, task_source)
            list of tasks to be added to the benchmark. Each task is represented as a tuple containing

        Returns:
        --------        
        self.built : bool
            True if the benchmark was successfully built, False otherwise
        '''

        # Create benchmark skeleton 
        os.mkdir(self.bench_path)
        # Create a benchmarks folder with tasks in them
        tasks_path = os.path.join(self.bench_path, "tasks")
        os.mkdir(tasks_path)
        log_path = os.path.join(self.bench_path, "logs")
        os.mkdir(log_path)

        # Create about.md
        about_path = os.path.join(self.bench_path, "about.md")
        if not about_body:
            about_body = "a {self.bench_name}."
        about_text= about_template.format({'bench_name':self.bench_name, 
                                           'text':about_body})
        with open(about_path, 'w') as file:
            file.write(about_text)

        # Initialize a git repo
        if not no_git:
            self.init_repo(self.bench_path)

        for task_name, task_source in new_tasks:
            self.add_task(task_name, task_source)

        self.write()    
        self.written = True
        return self.written


    def write(self):
        info = {'bench_name': self.bench_name, 
                'bench_concept': self.bench_concept, 
                'bench_path': self.bench_path, 
                'tasks': self.tasks}
        with open(os.path.join(self.bench_path, 'info.yml'), 'w') as f:
            yaml.dump(info, f)
        

    ### Initialize git repository
    def init_repo(bench_path):
        '''
        Initialize the benchmark folder as git repo with gitiginore for python 

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder
        '''
        current_dir = os.getcwd()
        os.chdir(bench_path)
        try:
            os.system("git init . -q")
            os.system("git branch -m main")
        except:
            print("git might not be initialized in your system. Please run \"git init . \" when setup")
        # Get python gitignore template and create .gitignore
        ignore_text = requests.get("https://raw.githubusercontent.com/github/gitignore/refs/heads/main/Python.gitignore")
        if ignore_text.status_code == 200:
            with open(".gitignore", 'a') as f:
                f.write(ignore_text.text)
        os.chdir(current_dir)


    def add_task(self, task_name, task_source):
        
        self.tasks.append(task_name)
            # setup_task(self.tasks_folder, task_name, task_source))

    # Create a benchmarks folder with tasks in them
    def initialize_task_dir(tasks_path, task_name: str, task_source=None,
                            is_huggingface=False):
        '''
        Initialize a new task folder in the benchmark repo

        Parameters:
        -----------
        tasks_path: str
            The path to the tasks folder inside the benchmark folder
        task_name: str
            The name of the task to be added. This will be used for the task folder name
        task_source: str or buffer
            The source of the task data. This can be a path to a local file or folder, 
            or a Hugging Face dataset identifier. 
            The content
        is_huggingface: bool
            Whether the task source is a Hugging Face dataset. If True, the task_source 
            should be like ownser/dataset_name
        '''

        print(f"Setting up {task_name}...", end='')
        task_folder = os.path.join(tasks_path, task_name)
        os.mkdir(task_folder) # TODO: check if folder exists and handle

        if is_huggingface:
            download_dataset(task_folder, task_source)
            print("Success")
            return


        # Path could be absolute or relative, check and work accordingly
        # if not task_source.startswith('/'):
        #     if task_source.startswith('./'):
        #         # TODO: Path could have one or more `../` use relpath to fix this block 
        #         task_source = task_source[2:]
        #     task_source = os.path.join(os.getcwd(), task_source)
            # print(f" path {task_source}\n\n") # Debugging
        
        #  could be a single file or a folder check and work accordignly
        if os.path.isdir(task_source):
            for sub in os.listdir(task_source):
                shutil.copy2(os.path.join(task_source, sub), task_folder)
        else:
            shutil.copy2(task_source, task_folder)
        print("Success")

    def download_dataset(task_folder: str, hf_path: str):
        '''
        dataset must have columns 'prompt' and 'canonical_solution' for now, can be expanded in the future.
        '''
        with open(os.path.join(task_folder, 'task.txt'), 'w') as f:
            f.write('{p}')

        dataset = load_dataset(hf_path)
        dataset_test = dataset['test']
        
        with open(os.path.join(task_folder, 'values.csv'), 'w') as f:
            f.write('p,res')
            for row in dataset_test:
                prompt = row['prompt']
                answer = row['canonical_solution']
                f.write(f"{prompt,answer}")


