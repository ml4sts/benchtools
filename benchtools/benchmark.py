# module to build benchmarks
# should create folder structure
import os
import shutil
import requests
import yaml
# from pathlib import Path # ???
from benchtools.task import Task
from pathlib import PurePath
from benchtools.runner import BenchRunner
from .utils import load_asset


about_template = """# {bench_name}

{text}

Generated by BenchTools
"""

class Bench():
    '''
        Benchmark with multiple tasks


    Attributes
    ----------
    bench_name : str
        Name of the benchmark.
    bench_path: str
        Path to where the benchmark folder and all its content reside
    task_folder:
        Path to tasks folder insise benchmark folder
    log folder:
        Path to logs folder inside benchmark folder
    tasks: list of Task objects
        
    is_built: bool

    Methods
    -------
        Build the benchmark directory.
    add_task()
        Add new tasks to the benchmark
    run()
        Run one task or all tasks of the benchmark.
    '''
    def __init__(self, name, base_path='.', bench_path=None, concept=None, tasks=[]):
        '''
        Initialize the benchmark object with the name and path to the benchmark folder.

        Parameters:
        -----------
        name: str
            name of the benchmark will be used for folder
        path: str or buffer
            path where the benchmark will be stored 
        tasks: list of Task objects
            list of tasks to be included in the benchmark. Each task should be an instance of the Task class
        '''

        # set up the object attributes
        self.display_name = name.strip()
        self.concept  = concept if concept else f'a benchmark about {name.strip()}'
        self.bench_name = name.strip().replace(" ", "_").lower()
        
        if bench_path:
            self.base_path = PurePath(bench_path).parent
            self.bench_path = bench_path
        else:
            # TODO: this way we don't have a base_path if above were true
            self.base_path = base_path
            self.bench_path = os.path.join(base_path, self.bench_name)

        
        
        if tasks:
            # All task objects have to be initialized before adding them to a benchmark
            self.tasks = {t.name:t for t in tasks} 
        else:
            self.tasks = {}
        
        # Written if the benchmark directory has been initialized
        self.written = os.path.exists(self.bench_path)

    
    @classmethod
    def from_folders(cls, bench_path):
        '''
        Load a benchmark object from a given path. 
        The path should point to the benchmark folder.

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder. The folder should contain the about.md file,
              tasks folder and logs folder.

        Returns:
        --------
        Bench
            An instance of the Bench class with the loaded benchmark.
        '''
        if not os.path.exists(bench_path):
            raise ValueError("The passed path doesn't exist.")
        
        
        content = os.listdir(bench_path)
        if 'info.yml' in content:
            # load the info
            info = Bench.load_info(bench_path)
        else:
            info = {}
            info['bench_name'] = PurePath(bench_path).parts[-1]
            info['concept'] = f'a benchmark about {info["bench_name"]}'

        if 'tasks' in content:
            task_folder = os.path.join(bench_path, 'tasks')
            task_list = os.listdir(task_folder)
            tasks = []
            for task_dir in task_list:
                # load the tasks
                task_path = os.path.join(task_folder, task_dir)
                task = Task.from_txt_csv(task_path)
                tasks.append(task)
        else:
            tasks = []

        
        return cls(name = info['bench_name'], 
                    bench_path = bench_path,
                    concept = info['concept'], tasks=tasks)
    
    @classmethod
    def from_yaml(cls, bench_path):
        """
        Load tasks from a YAML file and generate Task objects and add them to the bench

        Parameters
        ----------
        bench_path : str
            Path to the YAML file containing task templates and values.
        Returns
        -------
        self : Bench
            The Bench instance with tasks populated.
        """
        # load the info
        info = Bench.load_info(bench_path)

        # load the tasks
        yaml_file = os.path.join(bench_path, 'tasks.yml')
        with open(yaml_file, 'r') as file:
            task_list = yaml.safe_load(file)
        
        tasks =[]
        for task_dict in task_list:
            tasks.append(Task.from_dict(task_dict))


        return cls(name = info['bench_name'], bench_path =bench_path,
                   concept= info['concept'], tasks=tasks)

    @staticmethod
    def load_info(bench_path):
        with open(os.path.join(bench_path, 'info.yml'), 'r') as f:
            info = yaml.safe_load(f)
        
        return info
        

    def initialize_dir(self, no_git=False):
        '''
        write out the benchmark folder initially
        
        Parameters:
        -----------
        about_text: str
            description of the benchmark to be included in the about.md file
        no_git: bool
            whether to initialize a git repository in the benchmark folder
        new_tasks: list of tuples (task_name, task_source)
            list of tasks to be added to the benchmark. Each task is represented as a tuple containing

        Returns:
        --------        
        self.written: bool
            True if the benchmark was successfully built, False otherwise
        '''

        # Create benchmark skeleton 
        os.mkdir(self.bench_path)
        

        # Create about.md
        about_path = os.path.join(self.bench_path, "about.md")
        about_body = f"*{self.concept}*"
        about_text= about_template.format(bench_name=self.bench_name, 
                                           text = about_body)
        with open(about_path, 'w') as file:
            file.write(about_text)

        # Initialize a git repo
        if not no_git:
            self.init_repo(self.bench_path)

        # store tasks
        task_types = set([task.storage_type for task in self.tasks.values()])
        if 'csv' in task_types:
            os.mkdir(self.bench_path,'tasks')
            for task_name, task_object in self.tasks.items(): 
                task_object.write(self.bench_path)
        
        if task_types == {'yaml'}:
            task_list = []
            for task in self.tasks.values():
                task_list.append(task.get_dict())

            with open(os.path.join(self.bench_path,'tasks.yml'), 'w') as file:
                yaml.dump(task_list, file)

        self.write()    
        self.written = True
        return self.written


    def write(self):
        info = {'bench_name': self.bench_name, 
                'concept': self.concept, 
                'tasks': [task.get_bench_data() for task in self.tasks.values()]}
        with open(os.path.join(self.bench_path, 'info.yml'), 'w') as f:
            yaml.dump(info, f)

        # likely also write the tasks and the about, if need to be updated

    
    def write_tasks(self):
        for task in self.tasks:
            task.write(self.bench_path)
        

    ### Initialize git repository
    def init_repo(self, bench_path):
        '''
        Initialize the benchmark folder as git repo with gitiginore for python 

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder
        '''
        current_dir = os.getcwd()
        os.chdir(bench_path)
        try:
            os.system("git init . -q")
            os.system("git branch -m main")
        except:
            print("git might not be initialized in your system. Please run \"git init . \" when setup")
        # Get python gitignore template and create .gitignore
        ignore_text = load_asset('.gitignore')
        # ignore_text = requests.get("https://raw.githubusercontent.com/github/gitignore/refs/heads/main/Python.gitignore")
        # if ignore_text.status_code == 200:
        with open(".gitignore", 'a') as f:
            f.write(ignore_text)
        os.chdir(current_dir)


    def add_task(self, task_object:Task):

        # Add task object to bench's tasks
        self.tasks[task_object.name] = task_object

        # Check if written or not to write the task in the directory
        if self.written:
            task_object.write(self.bench_path)


    def run(self, runner=BenchRunner(), log_dir=None):
        '''
        Run the benchmark by running each task in the benchmark and logging the interactions.
        Parameters:
        -----------
        runner: BenchRunner 
            define which runner should be used for the task.
        
            runner.model : string
                the model to run the task on
            runner.api_url : string
                the url of the api to use for the task
            runner.runner_type: {ollama,openai}
                to use the Ollama runner, the script expects the model to be installed, and `ollama serve` running on localhost:11434
                to use OpenAI runner, you must have an API key set in your OPENAI_API_KEY environment variable
        log_dir: str
            Path to where the logs should be saved
        '''
        if not log_dir and not self.written:
            raise ValueError("Benchmark has not been written to disk yet, need to write in order to log.")
        
        # Run each task
        for name, task in self.tasks.items():
            self.run_task(task, runner, log_dir)


    def run_task(self, target_task=None, runner=BenchRunner(), log_dir=None): 
        '''
        run a specific task
        '''
        if not log_dir and not self.written:
            raise ValueError("Benchmark has not been written to disk yet, need to write in order to log.")

        # If user doesn't specify a log_dir, default to logs folder inside bench folder
        if not log_dir:
            log_dir = os.path.join(self.bench_path, 'logs')

        if not(target_task):
            # TODO: use a generator and make this have a state
            target_task = list[self.tasks.keys()][0] 

        if isinstance(target_task, str):
            task_object = self.tasks[target_task]
        elif isinstance(target_task, Task):
            task_object = target_task
        else:
            raise ValueError("target_task should be either a string (task name) or a Task object.")

        # TODO: Add log_dir to attributes?
        
        return task_object.run(runner, log_dir, self.bench_name, self.bench_path)


