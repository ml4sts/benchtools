# module to build benchmarks
# should create folder structure
import os
import shutil
import requests
import yaml
# from pathlib import Path # ???
from .task import Task
from pathlib import PurePath
from benchtools.runner import BenchRunner


about_template = """# {bench_name}

{text}

Generated by BenchTools
"""

class Bench():
    '''
        Benchmark with multiple tasks


    Attributes
    ----------
    bench_name : str
        Name of the benchmark.
    bench_path: str
        Path to where the benchmark folder and all its content reside
    task_folder:
        Path to tasks folder insise benchmark folder
    log folder:
        Path to logs folder inside benchmark folder
    tasks: list of Task objects
        
    is_built: bool

    Methods
    -------
        Build the benchmark directory.
    add_task()
        Add new tasks to the benchmark
    run()
        Run one task or all tasks of the benchmark.
    '''
    def __init__(self, name, base_path='.', bench_path=None, concept = None, tasks=[]):
        '''
        Initialize the benchmark object with the name and path to the benchmark folder.

        Parameters:
        -----------
        name: str
            name of the benchmark will be used for folder
        path: str or buffer
            path where the benchmark will be stored 
        
        tasks: list of Task objects
            list of tasks to be included in the benchmark. Each task should be an instance of the
        
        '''
        # load tasks from file structre and instantiate task objects for each, store those in a list.
        #    loading will 
        self.display_name = name.strip()
        self.concept  = concept if concept else f'a benchmark about {name.strip()}'
        self.bench_name = name.strip().replace(" ", "_").lower()
        
        if bench_path:
            self.base_path = PurePath(bench_path).parent
            self.bench_path = bench_path
        else:
            self.base_path = base_path
            self.bench_path = os.path.join(base_path, self.bench_name)

        self.tasks_folder = os.path.join(self.bench_path, 'tasks')
        if tasks:
            self.tasks = {t.name:t for t in tasks} # initialize a task object for each task.
        else:
            self.tasks = {}
        
        self.written = os.path.exists(self.bench_path)

    @classmethod
    def from_folders(cls, bench_path):
        '''
        Load a benchmark from a given path. The path should point to the benchmark folder.

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder. The folder should contain the about.md file, tasks folder and logs folder.

        Returns:
        --------
        Bench
            An instance of the Bench class with the loaded benchmark.
        '''
        if not os.path.exists(bench_path):
            raise ValueError("The passed path doesn't exist.")
        
        
        content = os.listdir(bench_path)
        if 'tasks.yml' in content:
            with open(os.path.join(bench_path, 'info.yml'), 'r') as f:
                info = yaml.safe_load(f)
        else:
            info = {}
            info['bench_name'] = PurePath(bench_path).parts[-1]
            info['concept'] = f'a benchmark about {info["bench_name"]}'

        if 'tasks' in content:
            task_folder = os.path.join(bench_path, 'tasks')
            task_list = os.listdir(task_folder)
            tasks = []
            for task_dir in task_list:
                # load the tasks
                task_path = os.path.join(task_folder, task_dir)
                task = Task.from_txt_csv(task_path)
                tasks.append(task)
        else:
            tasks = []

        
        return cls(name = info['bench_name'], 
                    bench_path = bench_path,
                    concept = info['concept'], tasks=tasks)
    
    @classmethod
    def from_yaml(cls, bench_path):
        """
        Load tasks from a YAML file and generate Task objects.

        Parameters
        ----------
        bench_path : str
            Path to the YAML file containing task templates and values.
        Returns
        -------
        self : Bench
            The Bench instance with tasks populated.
        """
        # load the info
        info = Bench.load_info(bench_path)

        # load the tasks
        yaml_file = os.path.join(bench_path, 'tasks.yml')
        with open(yaml_file, 'r') as file:
            task_list = yaml.safe_load(file)
        
        tasks =[]
        for task_dict in task_list:
            tasks.append(Task.from_dict(task_dict))


        return cls(name = info['bench_name'], bench_path =bench_path,
                   concept= info['concept'], tasks=tasks)

    @staticmethod
    def load_info(bench_path):
        with open(os.path.join(bench_path, 'info.yml'), 'r') as f:
            info = yaml.safe_load(f)
        
        return info
        

    def initialize_dir(self, no_git=False):
        '''
        write out the benchmark folder initially
        
        Parameters:
        -----------
        about_text: str
            description of the benchmark to be included in the about.md file
        no_git: bool
            whether to initialize a git repository in the benchmark folder
        new_tasks: list of tuples (task_name, task_source)
            list of tasks to be added to the benchmark. Each task is represented as a tuple containing

        Returns:
        --------        
        self.written: bool
            True if the benchmark was successfully built, False otherwise
        '''

        # Create benchmark skeleton 
        os.mkdir(self.bench_path)
        # Create a benchmarks folder with tasks in them
        tasks_path = os.path.join(self.bench_path, "tasks")
        os.mkdir(tasks_path)
        log_path = os.path.join(self.bench_path, "logs") # Do we want a log dir?
        os.mkdir(log_path) # Do we want a log dir?

        # Create about.md
        about_path = os.path.join(self.bench_path, "about.md")
        
        about_body = f"*{self.concept}*"
        about_text= about_template.format(bench_name=self.bench_name, 
                                           text = about_body)
        with open(about_path, 'w') as file:
            file.write(about_text)

        # Initialize a git repo
        if not no_git:
            self.init_repo(self.bench_path)

        task_types = set([task.storage_type for task in self.tasks.values()])
        if 'csv' in task_types:
            for task_name, task_object in self.tasks.items(): 
                task_object.write(tasks_path)
        
        if task_types == {'yaml'}:
            task_list = []
            for task in self.tasks.values():
                task_list.append(task.get_dict())

            with open(os.path.join(tasks_path,'tasks.yml'), 'w') as file:
                yaml.dump(task_list, file)

        self.write()    
        self.written = True
        return self.written


    def write(self):
        info = {'bench_name': self.bench_name, 
                'concept': self.concept, 
                'tasks': list(self.tasks.keys())}
        with open(os.path.join(self.bench_path, 'info.yml'), 'w') as f:
            yaml.dump(info, f)

        # likely also write the tasks and the about, if need to be updated

    
    def write_tasks(self):
        for task in self.tasks:
            task.write(self.tasks_folder)
        

    ### Initialize git repository
    def init_repo(self, bench_path):
        '''
        Initialize the benchmark folder as git repo with gitiginore for python 

        Parameters:
        -----------
        bench_path: str
            The path to the benchmark folder
        '''
        current_dir = os.getcwd()
        os.chdir(bench_path)
        try:
            os.system("git init . -q")
            os.system("git branch -m main")
        except:
            print("git might not be initialized in your system. Please run \"git init . \" when setup")
        # Get python gitignore template and create .gitignore
        ignore_text = requests.get("https://raw.githubusercontent.com/github/gitignore/refs/heads/main/Python.gitignore")
        if ignore_text.status_code == 200:
            with open(".gitignore", 'a') as f:
                f.write(ignore_text.text)
        os.chdir(current_dir)


    def add_task(self, task_object):
        # TODO: Look at content to create Task objects and add them to tasks
        # setup_task(self.tasks_folder, task_name, task_source))

        # self.tasks.append(task)
        self.tasks[task_object.name] = task_object


    def run(self, runner=BenchRunner()):
        '''
        Run the benchmark by running each task in the benchmark and logging the interactions.
        Parameters:
        -----------
        model: str default 'gemma3'
            The name of the model to use for running the tasks. Default is 'gemma3'.
        '''
        if not self.written:
            raise ValueError("Benchmark has not been written to disk yet, need to write in order to log.")
        # TODO deal with results 
        for name, task in self.tasks.items():
            self.run_task(task, runner)

    def run_task(self, target_task=None, runner=BenchRunner()): 
        if not(target_task):
            # TODO: use a generator and make this have a state
            target_task = list[self.tasks.keys()][0] 

        if isinstance(target_task, str):
            task_object = self.tasks[target_task]
        elif isinstance(target_task, Task):
            task_object = target_task
        else:
            raise ValueError("target_task should be either a string (task name) or a Task object.")
        
        logging_path = os.path.join(self.bench_path, 'logs') # Is this intentional or should we get log_path as an arg for this run method?
        return task_object.run(model,runner)


