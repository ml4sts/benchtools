import os
import yaml
import logging 
import datetime

def init_log_folder(log_path, model, task_info: dict):
    ''''
    Creates the log directories and sub-directories for a specific task.
    
    Parameters:
    -------------
    log_path: str
        The path to the log dir where the log file will be created.
    model: 
        The name of the model running the task
    task_info: dict
        A dictionary with all the task's info for which the logger is being initialized.
    '''
    # Get timestamp without fractions of seconds
    timestamp = int(datetime.datetime.now().timestamp())

    model_dir = os.path.join(log_path, model)
    if not os.path.exists(model_dir):
        os.mkdir(model_dir)

    task_dir = os.path.join(model_dir, task_info['name'])
    if not os.path.exists(task_dir):
        os.mkdir(task_dir)

    run_dir = os.path.join(task_dir, str(timestamp))
    os.mkdir(run_dir)

    # Create trace.yml with all the metadata
    trace = {} 
    for key, item in task_info.items():
        trace[key] = item
    
    with open(os.path.join(run_dir,'trace.yml'), 'w') as f:
        yaml.dump(trace, f)



    {
        # TODO: What can we benifit from the logger?
        # log_file = os.path.join(log_path, f'{task_name}_log.txt')
        # print(f"\nLOGPATH: {log_file}\n") # Debugging

        # formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        # handler = logging.FileHandler(log_file)
        # handler.setFormatter(formatter)

        # logger = logging.getLogger(task_name)
        # logger.setLevel(logging.INFO) # TODO add as an argument to the init functuion to use more options 
        # logger.addHandler(handler)

        # print(logger) # Debugging
        # return logger
    }

    return run_dir

def log_interaction(run_log_dir, prompt_idx, prompt, response, error):
    """
    Logs the event to the log folder specified by the user

    Parameters:
    -------------
    run_log_dir: str
        Path to a run-specific directory in a log directory specified in a call to the run method
    prompt_idx: str
        Index of the sub-task being logged
    prompt: str
        The input provided to the model.
    response: str
        The output generated by the model.
    error: str
        Any error from the runner
    """

    # Making this into a directory in case more files (possibly steps) were to be held in here
    prompt_dir = os.path.join(run_log_dir, f"prompt_{prompt_idx}")
    os.mkdir(prompt_dir)

    with open(os.path.join(prompt_dir, "log.txt"), 'w') as f:
        f.write("------ prompt ------\n")
        f.write(f"{prompt}\n\n")
        f.write("------ response ------\n")
        f.write(f"{response}\n\n")
    
    # Gather trace info
    with open(os.path.join(run_log_dir, "trace.yml"), 'r') as f:
            trace = yaml.safe_load(f) 

    step_trace = {
        'task_name': trace['task_name'],
        'template': trace['template'],
        'idx': prompt_idx,
        'error': error,
        'steps':{ 
            0:{ # In case a subtask had more than one step we can always make the 0 dynamic
                'prompt': prompt,
                'response': response
            }
        }
    }

    with open(os.path.join(prompt_dir, "log.yml"), 'w') as f:
        yaml.dump(step_trace, f)

    # TODO: What can we benifit from the logger?
    # logger.info(f'Input: {prompt}')
    # logger.info(f'Output: {response}')



    

